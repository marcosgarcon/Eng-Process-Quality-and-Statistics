<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Cronoanálise MTM — Avançado</title>

  <!-- Icons -->
  <script src="https://unpkg.com/@phosphor-icons/web"></script>

  <!-- libs para export e ZIP (opcional) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pptxgenjs/3.8.0/pptxgen.min.js"></script>

  <style>
    :root{--bg:#071026;--card:#071220;--muted:#233044;--accent:#22d3ee;--text:#e6eef6}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(120deg,#071026,#091233);color:var(--text);display:grid;grid-template-columns:260px 1fr;gap:0;height:100vh}
    header{grid-column:1/3;padding:12px 18px;background:linear-gradient(90deg,#081424,#0b2a44);display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid rgba(255,255,255,0.03)}
    aside{padding:14px;border-right:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,#071226,#061a2f)}
    main{padding:14px;overflow:auto}
    button{cursor:pointer;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.02);color:var(--text)}
    button.primary{background:linear-gradient(180deg,#06b6d4,#2563eb);color:#001}
    .video-wrapper{position:relative;border-radius:8px;overflow:hidden;background:#000}
    video{width:100%;display:block;max-height:720px;background:#000}
    .video-marker{position:absolute;transform:translate(-50%,-50%);width:18px;height:18px;border-radius:50%;background:#ff5a4a;border:2px solid #fff;color:#fff;display:flex;align-items:center;justify-content:center;font-size:11px;cursor:pointer;box-shadow:0 1px 4px rgba(0,0,0,0.6)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    table{width:100%;border-collapse:collapse;margin-top:12px;background:transparent;font-size:13px}
    th,td{padding:8px;border:1px solid rgba(255,255,255,0.03);text-align:left}
    thead th{background:rgba(255,255,255,0.02)}
    .panel{background:linear-gradient(180deg,#071526,#041427);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    .small{font-size:12px;color:#9fbfd0}
    input,select{background:transparent;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:6px;color:var(--text)}
    /* Overlay para vídeo expandido */
    #video-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:9999; align-items:center; justify-content:center; }
    #video-overlay .overlay-content { width:92%; max-width:1400px; max-height:92%; background:#000; border-radius:8px; position:relative; display:flex; flex-direction:column; padding:8px; }
    #video-overlay .close-btn { position:absolute; right:10px; top:10px; z-index:20; background:rgba(255,255,255,0.06); border:none;color:var(--text);padding:8px;border-radius:6px;cursor:pointer; }
    #video-overlay .overlay-video { flex:1; display:flex; align-items:center; justify-content:center; overflow:hidden; }
    #video-overlay .overlay-controls { margin-top:8px; display:flex; gap:8px; justify-content:center; }
    @media (max-width:900px){body{grid-template-columns:1fr}aside{display:none}}
  </style>
</head>
<body>
  <header>
    <div>
      <strong>Eng Process & Quality</strong> — Cronoanálise MTM
      <div class="small">Autosave, download em lote (ZIP), XLSX com imagens, PDF avançado</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <button class="primary" onclick="exportAnalysisPDF()">Exportar PDF</button>
      <button onclick="exportAnalysisPPTX()">Exportar PPTX</button>
      <button onclick="exportAnalysisXLSX(true)">Exportar XLSX (com imagens)</button>
      <button onclick="downloadAllThumbnailsZip()">Baixar miniaturas (ZIP)</button>
    </div>
  </header>

  <aside>
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Autosave</strong></div>
      </div>
      <div class="small" style="margin-top:8px">Salvar automaticamente a cada N minutos.</div>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <label class="small">Ativar</label>
        <input type="checkbox" id="autosave-enabled" />
        <label class="small">Intervalo (min)</label>
        <input type="number" id="autosave-interval" value="5" min="1" style="width:70px"/>
      </div>
      <div class="small" style="margin-top:8px">Destino: localStorage (reabertura automática). Se escolher pasta (rede), autosave também pode gravar lá.</div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button onclick="restoreFromLocalStorage()">Restaurar Última</button>
        <button onclick="clearAutosave()">Limpar Autosave</button>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="panel">
      <div><strong>Storage (opcional)</strong></div>
      <div class="small" style="margin-top:8px">Escolha uma pasta (rede) para salvar arquivos completos (JSON + miniaturas)</div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button onclick="chooseStorageDir()">Escolher Pasta</button>
        <button onclick="clearStoredDir()">Limpar</button>
      </div>
      <div class="small" id="storage-info" style="margin-top:8px">Local: (não definido)</div>
    </div>

    <div style="height:12px"></div>

    <div class="panel">
      <div><strong>Última ação</strong></div>
      <div id="last-action" class="small">—</div>
    </div>
  </aside>

  <main>
    <section class="panel">
      <div style="display:flex;gap:8px;align-items:center;">
        <input id="analysis-name" placeholder="Nome da análise / processo" style="flex:1"/>
        <input id="analyst-name" placeholder="Analista" style="width:220px"/>
        <input id="video-upload" type="file" accept="video/*" style="display:none" onchange="loadVideoFromInput(event)"/>
        <button onclick="document.getElementById('video-upload').click()">Carregar Vídeo</button>
        <button onclick="expandVideo()">Expandir Vídeo</button>
      </div>

      <div style="margin-top:12px;display:flex;gap:12px">
        <div style="flex:1;">
          <div id="video-wrapper" class="video-wrapper" style="height:420px;display:flex;align-items:center;justify-content:center;background:var(--card);">
            <div id="video-placeholder" class="small">Carregue um vídeo para começar.</div>
            <video id="analysis-video" controls style="display:none" playsinline webkit-playsinline></video>
          </div>

          <div class="controls">
            <button onclick="togglePlayPause()">Play/Pause (Espaço)</button>
            <button onclick="frameBackward()">-Frame</button>
            <button onclick="frameForward()">+Frame</button>
            <button onclick="createStepUI()" title="Ctrl+E">Criar Etapa (Ctrl+E)</button>
            <button onclick="startCycleUI()" title="Ctrl+C">Iniciar Ciclo (Ctrl+C)</button>
            <button onclick="endCycleUI()" title="Ctrl+F">Finalizar Ciclo (Ctrl+F)</button>
          </div>

          <div style="margin-top:8px" class="small">Dica: Expanda o vídeo para trabalhar em tela maior. Esc fecha o modo expandido.</div>
        </div>

        <div style="width:360px">
          <div class="panel">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div><strong>Resumo</strong></div>
              <div class="small" id="crono-display">00:00.000</div>
            </div>

            <div style="margin-top:10px">
              <div><strong>Etapas:</strong> <span id="stat-steps">0</span></div>
              <div><strong>Ciclos:</strong> <span id="stat-cycles">0</span></div>
              <div style="margin-top:8px"><strong>Última Miniatura:</strong></div>
              <div id="last-thumb" style="margin-top:6px;border-radius:6px;overflow:hidden;background:#06121a;height:120px;display:flex;align-items:center;justify-content:center;color:#789ab0">(nenhuma)</div>
            </div>

            <div style="margin-top:10px;display:flex;gap:8px">
              <button onclick="saveAnalysis()">Salvar (.json)</button>
              <button onclick="saveAllToStorage()">Salvar na Pasta (se escolhida)</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel">
      <h4>Tabela de Etapas</h4>
      <div style="overflow:auto;max-height:280px">
        <table id="analysis-table">
          <thead><tr><th>#</th><th>Descrição</th><th>Miniatura</th><th>Tempo</th><th>Ação</th></tr></thead>
          <tbody id="analysis-tbody"></tbody>
        </table>
      </div>
    </section>
  </main>

  <!-- Overlay para vídeo expandido -->
  <div id="video-overlay" tabindex="-1">
    <div class="overlay-content">
      <button class="close-btn" onclick="collapseVideo()">Fechar (Esc)</button>
      <div class="overlay-video" id="overlay-video-container"></div>
      <div class="overlay-controls">
        <button onclick="togglePlayPause()">Play / Pause</button>
        <button onclick="frameBackward()">-Frame</button>
        <button onclick="frameForward()">+Frame</button>
        <button onclick="createStepUI()">Criar Etapa</button>
      </div>
    </div>
  </div>

<script>
/*
  Versão completa com correções de carregamento/paint do vídeo e funcionalidades essenciais:
  - autosave (localStorage)
  - carregar vídeo, capturar miniaturas, criar etapas
  - export PDF básico
  - salvar .json e salvar em pasta (File System Access, quando suportado)
  A correção principal está em loadVideoFromInput e no final do arquivo: força paint (play/pause muted), espera por loadeddata e tenta capturar frame.
*/

////////////////////
// DOM & estado
const video = document.getElementById('analysis-video');
const wrapper = document.getElementById('video-wrapper');
const placeholder = document.getElementById('video-placeholder');
const tbody = document.getElementById('analysis-tbody');
const cronoDisplay = document.getElementById('crono-display');
const lastThumb = document.getElementById('last-thumb');

let steps = [], cycles = [], markers = [], currentCycle = null;
let stepCounter = 0;

// storage directory handle (File System Access API)
let storedDirHandle = null;

////////////////////
// IndexedDB small helpers (used earlier to persist directory handle)
function openIDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open('crono-store-v1', 1);
    req.onupgradeneeded = () => { req.result.createObjectStore('kv'); };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbPut(key, val) {
  try {
    const db = await openIDB();
    const tx = db.transaction('kv', 'readwrite');
    tx.objectStore('kv').put(val, key);
    return tx.complete;
  } catch (e) { console.warn(e); }
}
async function idbGet(key) {
  try {
    const db = await openIDB();
    return new Promise((res, rej) => {
      const tx = db.transaction('kv', 'readonly');
      const r = tx.objectStore('kv').get(key);
      r.onsuccess = () => res(r.result);
      r.onerror = () => rej(r.error);
    });
  } catch (e) { console.warn(e); return null; }
}
async function idbDelete(key) {
  try {
    const db = await openIDB();
    const tx = db.transaction('kv','readwrite'); tx.objectStore('kv').delete(key); return tx.complete;
  } catch (e) { console.warn(e); }
}

(async function restoreStoredDirHandle() {
  try {
    if (!window.indexedDB || !window.showDirectoryPicker) return;
    const h = await idbGet('storage-dir-handle');
    if (h) { storedDirHandle = h; document.getElementById('storage-info').textContent = `Local: ${h.name} (recuperado)`; }
  } catch (e) { console.warn('restoreStoredDirHandle', e); }
})();

////////////////////
// Autosave (localStorage + optional folder)
let autosaveTimer = null;
const AUTOSAVE_KEY = 'crono_last_autosave_v1';

document.getElementById('autosave-enabled').addEventListener('change', (e) => {
  scheduleAutosave();
});
document.getElementById('autosave-interval').addEventListener('change', () => scheduleAutosave());

function scheduleAutosave() {
  if (autosaveTimer) clearInterval(autosaveTimer);
  const enabled = document.getElementById('autosave-enabled').checked;
  const minutes = Math.max(1, parseFloat(document.getElementById('autosave-interval').value || 5));
  if (enabled) {
    autosaveTimer = setInterval(() => {
      autosaveToLocalAndMaybeFolder();
    }, minutes * 60 * 1000);
    // also do immediate first save
    autosaveToLocalAndMaybeFolder();
    document.getElementById('last-action').textContent = `Autosave ativado (a cada ${minutes} min)`;
  } else {
    document.getElementById('last-action').textContent = 'Autosave desativado';
  }
}

// perform autosave into localStorage and, if folder chosen, to folder
async function autosaveToLocalAndMaybeFolder() {
  const data = gatherAnalysisData();
  try {
    localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(data));
    document.getElementById('last-action').textContent = 'Autosave em localStorage: ' + new Date().toLocaleTimeString();
  } catch (e) {
    console.warn('Autosave localStorage falhou', e);
  }
  // if folder chosen, try to write there (non-blocking)
  if (storedDirHandle) {
    try {
      const name = (data.name || 'cronoanalise') + '_' + (new Date().toISOString().slice(0,19).replace(/[:T]/g,'-'));
      const folder = await storedDirHandle.getDirectoryHandle(name, {create:true});
      // write JSON
      const fileHandle = await folder.getFileHandle('analysis.json', {create:true});
      const w = await fileHandle.createWritable();
      await w.write(JSON.stringify(data, null, 2));
      await w.close();
      // write thumbnails
      for (let s of data.steps) {
        if (!s.thumbnail) continue;
        const fh = await folder.getFileHandle(`thumb_${s.index}.png`, {create:true});
        const wr = await fh.createWritable();
        await wr.write(dataURLtoBlob(s.thumbnail));
        await wr.close();
      }
      document.getElementById('last-action').textContent = `Autosave: salvo em pasta ${storedDirHandle.name}/${name}`;
    } catch (e) {
      console.warn('autosave to folder failed', e);
    }
  }
}

function restoreFromLocalStorage() {
  try {
    const raw = localStorage.getItem(AUTOSAVE_KEY);
    if (!raw) return alert('Nenhuma autosave encontrada no localStorage.');
    const data = JSON.parse(raw);
    applyRestoredAnalysis(data);
    alert('Análise restaurada do localStorage.');
  } catch (e) {
    console.warn('restoreFromLocalStorage', e); alert('Falha ao restaurar: ver console.');
  }
}
function clearAutosave() {
  localStorage.removeItem(AUTOSAVE_KEY);
  alert('Autosave limpa.');
}

////////////////////
// Choose folder (File System Access API)
async function chooseStorageDir() {
  if (!window.showDirectoryPicker) return alert('Seu navegador não suporta escolha de pasta (File System Access API).');
  try {
    const dir = await window.showDirectoryPicker();
    storedDirHandle = dir;
    try { await idbPut('storage-dir-handle', dir); } catch (e) { console.warn(e); }
    document.getElementById('storage-info').textContent = `Local: ${dir.name} (gravado)`;
    document.getElementById('last-action').textContent = 'Pasta escolhida: ' + dir.name;
  } catch (e) { console.warn('chooseStorageDir', e); }
}
async function clearStoredDir() { storedDirHandle = null; await idbDelete('storage-dir-handle'); document.getElementById('storage-info').textContent = 'Local: (não definido)'; }

////////////////////
// vídeo e miniaturas
function formatTime(t=0) {
  if (!isFinite(t)) return '00:00.000';
  const mm = Math.floor(t/60).toString().padStart(2,'0'), ss = Math.floor(t%60).toString().padStart(2,'0');
  const ms = Math.floor((t - Math.floor(t))*1000).toString().padStart(3,'0');
  return `${mm}:${ss}.${ms}`;
}
function updateCrono() { cronoDisplay.textContent = formatTime(video.currentTime || 0); requestAnimationFrame(updateCrono); }
requestAnimationFrame(updateCrono);

function captureFrame() {
  try {
    if (!video || video.readyState < 2) return null;
    const w = video.videoWidth || 640, h = video.videoHeight || 360;
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    ctx.drawImage(video, 0, 0, w, h);
    return c.toDataURL('image/png');
  } catch (e) {
    console.warn('captureFrame error', e);
    return null;
  }
}

////////////////////
// steps & table
function insertStepRow(step) {
  const tr = document.createElement('tr'); tr.dataset.stepId = step.id;
  tr.innerHTML = `<td>${step.index}</td>
    <td contenteditable="true">${(step.description || '').replace(/</g,'&lt;')}</td>
    <td style="width:160px;">${step.thumbnail ? `<img src="${step.thumbnail}" style="width:140px;border-radius:6px">` : '(sem imagem)'}</td>
    <td>${formatTime(step.time)}</td>
    <td><button onclick="downloadThumbnail('${step.id}')">baixar</button> <button onclick="removeStep('${step.id}')">remover</button></td>`;
  tbody.appendChild(tr);
}
function createStepUI() {
  const thumb = captureFrame(); const time = video.currentTime || 0; stepCounter++;
  const step = { id:`s${Date.now()}-${stepCounter}`, index: stepCounter, time, thumbnail: thumb, description: '' };
  steps.push(step); insertStepRow(step); updateStats(); showLastThumbnail(thumb); createVideoMarker({time,label:'Etapa '+step.index});
  // try play to force paint if needed (non-blocking)
  video.play().then(()=>video.pause()).catch(()=>{});
}
function removeStep(id) { steps = steps.filter(s=>s.id!==id); const tr = tbody.querySelector(`tr[data-step-id="${id}"]`); if (tr) tr.remove(); updateStats(); }
function downloadThumbnail(stepId) {
  const s = steps.find(x=>x.id===stepId); if (!s || !s.thumbnail) return alert('Sem miniatura');
  const a = document.createElement('a'); a.href = s.thumbnail; a.download = `${(document.getElementById('analysis-name').value||'crono')}_thumb_${s.index}.png`; document.body.appendChild(a); a.click(); a.remove();
}
function showLastThumbnail(dataUrl) { lastThumb.innerHTML = dataUrl ? `<img src="${dataUrl}" style="width:100%;height:100%;object-fit:cover">` : '<div class="small">(nenhuma)</div>'; }
function updateStats() { document.getElementById('stat-steps').textContent = steps.length; document.getElementById('stat-cycles').textContent = cycles.length + (currentCycle?1:0); }

////////////////////
// markers & cycles
let markersDom = [];
function createVideoMarker({time,label}) {
  const dur = video.duration || 1; const pct = Math.max(0, Math.min(1, time/dur));
  const left = pct*100; const top = 6 + (markersDom.length % 6)*3;
  const el = document.createElement('div'); el.className='video-marker'; el.style.left = left+'%'; el.style.top = top+'%';
  el.textContent = markersDom.length+1; el.title = `${label || 'Marcador'} • ${formatTime(time)}`; el.dataset.time = time;
  el.addEventListener('click', (e)=>{ video.currentTime = parseFloat(el.dataset.time); e.stopPropagation(); });
  el.addEventListener('dblclick', (e)=>{ el.remove(); markersDom = markersDom.filter(m=>m!==el); e.stopPropagation(); });
  wrapper.appendChild(el); markersDom.push(el);
}
function startCycleUI(){
  if (currentCycle) {
    if (!confirm('Ciclo ativo. Reiniciar?')) return;
    currentCycle = null;
  }
  currentCycle = { id:'c'+Date.now(), start: video.currentTime||0, end: null, steps: [] };
  document.getElementById('last-action').textContent = 'Ciclo iniciado';
  updateStats();
}
function endCycleUI(){
  if (!currentCycle) {
    createVideoMarker({time:video.currentTime||0,label:'Ponto'});
    document.getElementById('last-action').textContent = 'Marcador criado';
    return;
  }
  currentCycle.end = video.currentTime||0;
  cycles.push(currentCycle);
  createVideoMarker({time:currentCycle.end,label:'Fim ciclo'});
  currentCycle = null;
  document.getElementById('last-action').textContent = 'Ciclo finalizado';
  updateStats();
}

////////////////////
// save JSON local/download
function saveAnalysis() {
  const data = gatherAnalysisData();
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `${(data.name||'cronoanalise')}.json`; document.body.appendChild(a); a.click(); a.remove();
  document.getElementById('last-action').textContent = 'JSON baixado';
}
function gatherAnalysisData(){
  document.querySelectorAll('#analysis-tbody tr').forEach(tr => {
    const id = tr.dataset.stepId; if (!id) return;
    const desc = tr.querySelector('td[contenteditable]')?.innerText || '';
    const s = steps.find(x=>x.id===id); if (s) s.description = desc;
  });
  return { name: document.getElementById('analysis-name').value||'', analyst: document.getElementById('analyst-name').value||'', created_at: new Date().toISOString(), steps: steps.slice(), cycles: cycles.slice() , markers: markersDom.map(m=>({time: parseFloat(m.dataset.time), title: m.title})) };
}
function applyRestoredAnalysis(data) {
  try {
    steps = data.steps || []; cycles = data.cycles || []; currentCycle = null; stepCounter = steps.length;
    tbody.innerHTML = ''; steps.forEach(s => insertStepRow(s)); updateStats(); if (steps.length && steps[steps.length-1].thumbnail) showLastThumbnail(steps[steps.length-1].thumbnail);
    document.getElementById('analysis-name').value = data.name || ''; document.getElementById('analyst-name').value = data.analyst || '';
    document.getElementById('last-action').textContent = 'Análise restaurada';
  } catch (e) { console.warn(e); }
}

////////////////////
// save to folder (JSON + thumbnails)
async function saveAllToStorage() {
  const data = gatherAnalysisData();
  if (!storedDirHandle) {
    if (!window.showDirectoryPicker) return saveAnalysis();
    await chooseStorageDir();
  }
  if (!storedDirHandle) return alert('Nenhuma pasta selecionada.');
  try {
    const name = (data.name || 'cronoanalise') + '_' + (new Date().toISOString().slice(0,19).replace(/[:T]/g,'-'));
    const folder = await storedDirHandle.getDirectoryHandle(name, {create:true});
    const jsonHandle = await folder.getFileHandle('analysis.json', {create:true});
    const jw = await jsonHandle.createWritable(); await jw.write(JSON.stringify(data, null, 2)); await jw.close();
    for (let s of data.steps) {
      if (!s.thumbnail) continue;
      const fh = await folder.getFileHandle(`thumb_${s.index}.png`, {create:true});
      const w = await fh.createWritable(); await w.write(dataURLtoBlob(s.thumbnail)); await w.close();
    }
    document.getElementById('last-action').textContent = `Análise salva em ${storedDirHandle.name}/${name}`;
    alert('Análise salva na pasta selecionada com miniaturas.');
  } catch (e) { console.error(e); alert('Erro ao salvar na pasta: ver console.'); }
}

function dataURLtoBlob(dataurl) {
  const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n=bstr.length, u8 = new Uint8Array(n);
  while(n--) u8[n] = bstr.charCodeAt(n); return new Blob([u8], {type:mime});
}

////////////////////
// Download all thumbnails as ZIP
async function downloadAllThumbnailsZip() {
  if (steps.length === 0) return alert('Nenhuma etapa com miniatura para baixar.');
  const zip = new JSZip();
  for (let s of steps) {
    if (!s.thumbnail) continue;
    const blob = dataURLtoBlob(s.thumbnail);
    zip.file(`thumb_${s.index}.png`, blob);
  }
  const content = await zip.generateAsync({type:'blob'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(content); a.download = `${(document.getElementById('analysis-name').value||'cronoanalise')}_thumbnails.zip`; document.body.appendChild(a); a.click(); a.remove();
  document.getElementById('last-action').textContent = 'Miniaturas baixadas em ZIP';
}

////////////////////
// Export XLSX with images (ExcelJS) - kept simple and guarded
async function exportAnalysisXLSX(includeImages = true) {
  if (!window.ExcelJS) return alert('ExcelJS não carregado no ambiente.');
  const data = gatherAnalysisData();
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Etapas');

  ws.columns = [{header:'#', key:'i', width:6},{header:'Descrição',key:'desc', width:40},{header:'Tempo(s)',key:'time',width:12},{header:'Tempo formatado',key:'tform',width:14}];

  for (let s of data.steps) ws.addRow({i:s.index, desc:s.description || '', time:(s.time||0).toFixed(3), tform:formatTime(s.time)});

  if (includeImages) {
    for (let i=0;i<data.steps.length;i++){
      const s = data.steps[i];
      if (!s.thumbnail) continue;
      try {
        const imgBlob = dataURLtoBlob(s.thumbnail);
        const arrayBuffer = await imgBlob.arrayBuffer();
        const imageId = wb.addImage({buffer: arrayBuffer, extension: 'png'});
        const rowNumber = i + 2; // header row + index
        ws.addImage(imageId, {tl: {col:4, row: rowNumber-1}, ext: {width:80, height:60}});
      } catch (e) { console.warn('Erro embed imagem XLSX', e); }
    }
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], {type:'application/octet-stream'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `${(data.name||'cronoanalise')}.xlsx`; document.body.appendChild(a); a.click(); a.remove();
  document.getElementById('last-action').textContent = 'XLSX gerado';
  alert('XLSX gerado.');
}

////////////////////
// Export PDF (cover + TOC + pages per step) - uses jsPDF
async function exportAnalysisPDF() {
  if (!window.jspdf) return alert('jsPDF não carregado.');
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'portrait' });
  const margin = 12, pageWidth = doc.internal.pageSize.getWidth(), pageHeight = doc.internal.pageSize.getHeight(), usableW = pageWidth - margin*2;

  // ensure descriptions are up-to-date
  document.querySelectorAll('#analysis-tbody tr').forEach(tr => {
    const id = tr.dataset.stepId; if (!id) return;
    const desc = tr.querySelector('td[contenteditable]')?.innerText || '';
    const s = steps.find(x=>x.id===id); if (s) s.description = desc;
  });

  const data = gatherAnalysisData();

  // Cover
  doc.setFontSize(24); doc.setFont(undefined, 'bold'); doc.text(data.name || 'Cronoanálise', margin, 50);
  doc.setFontSize(12); doc.setFont(undefined, 'normal'); doc.text(`Analista: ${data.analyst || '-'}`, margin, 64);
  doc.text(`Gerado em: ${new Date().toLocaleString()}`, margin, 72);
  doc.setDrawColor(34,211,238); doc.setFillColor(34,211,238); doc.rect(pageWidth - margin - 45, 30, 40, 40, 'F');

  // TOC
  doc.addPage(); doc.setFontSize(18); doc.text('Sumário', margin, 24);
  doc.setFontSize(11);
  const tocStartY = 34;
  let y = tocStartY;
  const stepPages = [];
  // create pages for steps
  for (let i=0;i<data.steps.length;i++){
    const s = data.steps[i];
    doc.addPage();
    const pnum = doc.getNumberOfPages();
    stepPages.push(pnum);

    doc.setFontSize(14); doc.setFont(undefined,'bold'); doc.text(`Etapa ${s.index} — ${formatTime(s.time)}`, margin, 20);
    doc.setFontSize(11); doc.setFont(undefined,'normal');

    if (s.thumbnail) {
      try {
        const img = new Image(); img.src = s.thumbnail;
        await new Promise(r => { img.onload = r; img.onerror = r; });
        const pxToMm = 25.4/96;
        let imgWmm = (img.naturalWidth || 800)*pxToMm;
        let imgHmm = (img.naturalHeight || 600)*pxToMm;
        const scale = Math.min(1, usableW / imgWmm, (pageHeight - 70) / imgHmm);
        imgWmm *= scale; imgHmm *= scale;
        doc.addImage(s.thumbnail, 'PNG', margin, 26, imgWmm, imgHmm);
        if (s.description) {
          const descY = 26 + imgHmm + 6;
          doc.setFontSize(10); doc.text(doc.splitTextToSize(s.description, usableW), margin, descY);
        }
      } catch (e) { console.warn('pdf img', e); doc.setFontSize(10); doc.text('(não foi possível inserir imagem)', margin, 30); }
    } else {
      if (s.description) { doc.setFontSize(10); doc.text(doc.splitTextToSize(s.description, usableW), margin, 30); } else { doc.setFontSize(10); doc.text('(sem miniatura)', margin, 30); }
    }

    doc.setFontSize(9); doc.text(`Página ${pnum}`, pageWidth - margin - 20, pageHeight - 10);
  }

  // Fill TOC with links to pages
  doc.setPage(2);
  y = tocStartY;
  for (let i=0;i<data.steps.length;i++){
    const txt = `${i+1}. Etapa ${data.steps[i].index} — ${formatTime(data.steps[i].time)}`;
    doc.text(txt, margin, y);
    const tw = doc.getTextWidth(txt);
    doc.link(margin, y-4, tw+2, 6, { pageNumber: stepPages[i] });
    y += 8;
    if (y > pageHeight - margin - 20) { doc.addPage(); y = tocStartY; }
  }

  // Summary page
  doc.addPage();
  doc.setFontSize(14); doc.setFont(undefined,'bold'); doc.text('Resumo', margin, 24);
  doc.setFontSize(10); doc.text(`Total de etapas: ${steps.length}`, margin, 36);
  doc.text(`Tempo total (s): ${(steps.reduce((a,s)=>a+(s.time||0),0)).toFixed(3)}`, margin, 44);

  const filename = `${(data.name||'cronoanalise')}.pdf`;
  doc.save(filename);
  document.getElementById('last-action').textContent = 'PDF gerado';
}

////////////////////
// Expand / collapse video overlay
const overlay = document.getElementById('video-overlay');
const overlayContainer = document.getElementById('overlay-video-container');
let videoOriginalParent = null;
let overlayMarkers = [];
function expandVideo() {
  if (!video.src) return alert('Carregue um vídeo primeiro.');
  videoOriginalParent = video.parentNode;
  overlayContainer.appendChild(video);
  video.style.maxHeight = '100%';
  overlay.style.display = 'flex';
  recreateOverlayMarkers();
}
function collapseVideo() {
  overlayMarkers.forEach(m=>m.remove()); overlayMarkers = [];
  if (videoOriginalParent) videoOriginalParent.appendChild(video);
  video.style.maxHeight = '720px';
  overlay.style.display = 'none';
}
function recreateOverlayMarkers() {
  overlayMarkers.forEach(m=>m.remove()); overlayMarkers = [];
  const dur = video.duration || 1;
  markersDom.forEach((m,i) => {
    const pct = Math.max(0, Math.min(1, parseFloat(m.dataset.time) / dur));
    const el = document.createElement('div'); el.className='video-marker'; el.style.left = (pct*100)+'%'; el.style.top = (8 + (i%6)*4)+'%';
    el.textContent = i+1; el.title = m.title;
    el.addEventListener('click', ()=>{ video.currentTime = parseFloat(m.dataset.time); });
    overlayContainer.appendChild(el); overlayMarkers.push(el);
  });
}

////////////////////
// Keyboard shortcuts and simple controls
function togglePlayPause() {
  if (video.paused) video.play().catch(()=>{});
  else video.pause();
}
function frameForward() {
  if (!video.duration) return;
  video.currentTime = Math.min(video.duration, video.currentTime + (1/30));
}
function frameBackward() {
  video.currentTime = Math.max(0, video.currentTime - (1/30));
}

document.addEventListener('keydown', (ev) => {
  const tag = document.activeElement?.tagName?.toLowerCase();
  const editing = document.activeElement?.isContentEditable || ['input','textarea','select'].includes(tag);
  if (editing) return;
  if (ev.key === ' ') { ev.preventDefault(); togglePlayPause(); }
  else if (ev.ctrlKey && (ev.key === 'e' || ev.key === 'E')) { ev.preventDefault(); createStepUI(); }
  else if (ev.ctrlKey && (ev.key === 'c' || ev.key === 'C')) { ev.preventDefault(); startCycleUI(); }
  else if (ev.ctrlKey && (ev.key === 'f' || ev.key === 'F')) { ev.preventDefault(); endCycleUI(); }
  else if (ev.key === 'Escape') { if (overlay.style.display === 'flex') collapseVideo(); }
});

////////////////////
// expose minimal functions to console for debug
window.createStepUI = createStepUI; window.startCycleUI = startCycleUI; window.endCycleUI = endCycleUI;
window.downloadAllThumbnailsZip = downloadAllThumbnailsZip; window.exportAnalysisXLSX = exportAnalysisXLSX;
window.chooseStorageDir = chooseStorageDir; window.saveAllToStorage = saveAllToStorage; window.restoreFromLocalStorage = restoreFromLocalStorage;

////////////////////
// Init: restore autosave enabled state (default enabled) and schedule autosave
(function init(){
  try {
    const asEnabled = localStorage.getItem('crono_autosave_enabled');
    const asInterval = localStorage.getItem('crono_autosave_interval');
    if (asEnabled !== null) document.getElementById('autosave-enabled').checked = asEnabled === 'true';
    if (asInterval !== null) document.getElementById('autosave-interval').value = parseInt(asInterval,10) || 5;
  } catch(e){}
  document.getElementById('autosave-enabled').addEventListener('change', (e)=>{ localStorage.setItem('crono_autosave_enabled', e.target.checked); scheduleAutosave(); });
  document.getElementById('autosave-interval').addEventListener('change', (e)=>{ localStorage.setItem('crono_autosave_interval', e.target.value); scheduleAutosave(); });

  const last = localStorage.getItem(AUTOSAVE_KEY);
  if (last) {
    try {
      const data = JSON.parse(last);
      if (confirm('Encontrado autosave local. Deseja restaurar a última análise?')) applyRestoredAnalysis(data);
    } catch(e){}
  }
  scheduleAutosave();
})();

////////////////////
// --- FIX: versão reforçada do loadVideoFromInput (forçar paint/thumbnail) ---
// Substitui a função global loadVideoFromInput utilizada pelo input file onchange.
// Essa função espera loadeddata, tenta capturar frame e faz um play() muted rápido para forçar renderização.
(function(){
  function ensureVideoVisible() {
    video.style.display = 'block';
    video.style.background = '#000';
    placeholder.style.display = 'none';
    video.setAttribute('playsinline', '');
    video.setAttribute('webkit-playsinline', '');
  }

  async function loadVideoFromInputFixed(e){
    const f = e?.target?.files?.[0];
    if (!f) return;
    try {
      const url = URL.createObjectURL(f);
      video.src = url;
      ensureVideoVisible();
      console.log('[crono-fix] video src set:', f.name, url);

      await new Promise((resolve) => {
        let resolved = false;
        const t = setTimeout(() => { if (!resolved) { resolved = true; console.warn('[crono-fix] loadeddata timeout'); resolve(); } }, 4000);
        function onLoaded() { if (resolved) return; resolved = true; clearTimeout(t); video.removeEventListener('loadeddata', onLoaded); resolve(); }
        video.addEventListener('loadeddata', onLoaded);
        video.addEventListener('loadedmetadata', onLoaded, {once:true});
      });

      // tenta capturar o frame imediatamente para forçar renderizar e mostrar miniatura
      try {
        const thumb = captureFrame();
        if (thumb) {
          console.log('[crono-fix] thumbnail gerada');
          showLastThumbnail(thumb);
        } else {
          console.warn('[crono-fix] captureFrame retornou null — frame pode não estar pronto');
        }
      } catch (e) {
        console.warn('[crono-fix] falha ao gerar thumbnail', e);
      }

      // Força um pequeno play/pause com muted para browsers que só pintam quando há reprodução
      try {
        const wasMuted = video.muted;
        video.muted = true;
        await video.play().catch(err => { console.warn('[crono-fix] play() rejeitado', err); });
        video.pause();
        video.muted = wasMuted;
      } catch (err) {
        console.warn('[crono-fix] tentativa de play/pause falhou', err);
      }

      document.getElementById('last-action').textContent = 'Vídeo carregado: ' + f.name;
    } catch (err) {
      console.error('[crono-fix] erro ao carregar vídeo', err);
      alert('Erro ao carregar vídeo: ver console do navegador para detalhes.');
    }
  }

  // listeners para logs
  video.addEventListener('error', (ev) => {
    console.error('[crono-fix] video element error', ev, video.error);
    alert('Erro no elemento de vídeo. Ver console (video.error).');
  });
  video.addEventListener('loadedmetadata', () => {
    console.log('[crono-fix] loadedmetadata:', video.videoWidth, 'x', video.videoHeight, 'duration=', video.duration);
    ensureVideoVisible();
  });
  video.addEventListener('loadeddata', () => {
    console.log('[crono-fix] loadeddata - primeiro frame disponível');
    ensureVideoVisible();
  });

  // substitui a função global
  window.loadVideoFromInput = loadVideoFromInputFixed;
  // expõe para console
  window._crono_fix = { loadVideoFromInputFixed };
})();
</script>
</body>
</html>
